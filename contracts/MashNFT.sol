// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "hardhat/console.sol";
import "@openzeppelin/contracts/access/Ownable.sol";
import "@openzeppelin/contracts-upgradeable/token/ERC721/ERC721Upgradeable.sol";
import "@openzeppelin/contracts-upgradeable/token/ERC721/extensions/ERC721PausableUpgradeable.sol";
import "@openzeppelin/contracts-upgradeable/access/AccessControlEnumerableUpgradeable.sol";
import "@openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol";
import "@openzeppelin/contracts-upgradeable/utils/CountersUpgradeable.sol";
import "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";
import "@openzeppelin/contracts/utils/math/SafeMath.sol";
import "./RoyaltyUtils.sol";

/**
 * @dev {ERC721} token, including:
 *
 *  - ability for holders to burn (destroy) their tokens
 *  - a minter role that allows for token minting (creation)
 *  - a pauser role that allows to stop all token transfers
 *  - token ID and URI autogeneration
 *
 * This contract uses {AccessControl} to lock permissioned functions using the
 * different roles - head to its documentation for details.
 *
 * The account that deploys the contract will be granted the minter and pauser
 * roles, as well as the default admin role, which will let it grant both minter
 * and pauser roles to other accounts.
 *
 * _Deprecated in favor of https://wizard.openzeppelin.com/[Contracts Wizard]._
 */

//MashNFTPresetMinterPauserAutoIdUpgradeable
contract MashNFT is
    Ownable, 
    Initializable, 
    ContextUpgradeable,
    AccessControlEnumerableUpgradeable,
    ERC721PausableUpgradeable,
    RoyaltyUtils
{
    bytes32 public constant MINTER_ROLE = keccak256("MINTER_ROLE");
    bytes32 public constant PAUSER_ROLE = keccak256("PAUSER_ROLE");

    uint256 public _tokenCounter;
    string private _name;
    string private _symbol;
    string private _baseTokenURI;
    uint256 private MAX_TOKENS;
    uint256 private MINT_PRICE;
    uint8 _royaltyPercent;
    uint256 _mash_fee = 10;

    mapping (uint256 => string) private _tokenURIbyID;
    string[] private _tokenURIs;

    mapping(uint256 => RoyaltyReceiver) _royalties;

    address private deployer;
    address[] private tokens;
    address private _creator; 

    struct RoyaltyReceiver {
        address creator;
        uint8 royaltyPercent;
    }

    event Mint(address _from, uint256 tokenId, string tokenURI, address creator, uint8 royaltyPercent);
    event RoyaltySet(uint256 tokenId, address _creator, uint8 _royaltyPercent);
    event CreatorMintPayout(uint256 tokenId, address _creator, uint256 mintPrice);

    constructor() {
        deployer = msg.sender;
    }

    function initialize(
        string memory name,
        string memory symbol,
        string memory baseTokenURI,
        uint256 max_tokens, 
        uint256 mintPrice,
        address creator,
        uint8 royaltyPercent
    ) public virtual initializer {
        __ERC721PresetMinterPauserAutoId_init(name, symbol, baseTokenURI);
        _tokenCounter = 0;
        MAX_TOKENS = max_tokens;
        MINT_PRICE = mintPrice;
        _creator = creator;
        _royaltyPercent = royaltyPercent;
    }

    /**
     * @dev Grants `DEFAULT_ADMIN_ROLE`, `MINTER_ROLE` and `PAUSER_ROLE` to the
     * account that deploys the contract.
     *
     * Token URIs will be autogenerated based on `baseURI` and their token IDs.
     * See {ERC721-tokenURI}.
     */
    function __ERC721PresetMinterPauserAutoId_init(
        string memory name,
        string memory symbol,
        string memory baseTokenURI
    ) internal onlyInitializing {
        __ERC721_init_unchained(name, symbol);
        __Pausable_init_unchained();
        __ERC721PresetMinterPauserAutoId_init_unchained(name, symbol, baseTokenURI);
    }

    function __ERC721PresetMinterPauserAutoId_init_unchained(
        string memory name,
        string memory symbol,
        string memory baseTokenURI
    ) internal onlyInitializing {
        _name = name;
        _symbol = symbol;
        _baseTokenURI = baseTokenURI;

        _setupRole(DEFAULT_ADMIN_ROLE, _msgSender());

        _setupRole(MINTER_ROLE, _msgSender());
        _setupRole(PAUSER_ROLE, _msgSender());
    }

    function _beforeTokenTransfer(
        address from,
        address to,
        uint256 tokenId
    ) internal virtual override(ERC721Upgradeable, ERC721PausableUpgradeable) {
        super._beforeTokenTransfer(from, to, tokenId);
    }

    function grantPauserRole(address pauser) public onlyOwner {
        _setupRole(PAUSER_ROLE, pauser);
    }

    function _msgSender() internal view override(ContextUpgradeable, Context) returns (address) {
        return msg.sender;
    }

    function _msgData() internal view override(ContextUpgradeable, Context) returns (bytes calldata) {
        return msg.data;
    }

    function _baseURI() internal view virtual override returns (string memory) {
        return _baseTokenURI;
    }

    function getMaxTokens() public view returns (uint256) {
        return MAX_TOKENS;
    }

    function getMintPrice() public view returns (uint256) {
        return MINT_PRICE;
    }

    function getTokenURIbyID(uint256 _tokenId) virtual public view returns(string memory) {
        require(
            _exists(_tokenId),
            "ERC721Metadata: URI set of nonexistent token"
        );
        return _tokenURIbyID[_tokenId];
    }

    function getTokenURIs() virtual public view returns(string [] memory) {
        return _tokenURIs;
    }

    function getRoyaltyInfo(uint256 tokenId, uint256 salePrice) public view returns (address receiver, uint256 royaltyPayout) {
        receiver = _royalties[tokenId].creator;
        royaltyPayout = getSalePayoutForCreator(_royalties[tokenId].royaltyPercent, salePrice);
        return (receiver, royaltyPayout);
    }

    function _setTokenURI(uint256 _tokenId, string memory _tokenURI) internal virtual {
        require(
            _exists(_tokenId),
            "ERC721Metadata: URI set of nonexistent token"
        );  
        _tokenURIbyID[_tokenId] = _tokenURI;
    }

    /**
     * @notice Allows to set the royalties on the contract
     * conversion: desired_percentage (int) * 100 -> royalty_val (uint8)
    */
    function _setRoyalty(uint256 tokenId) internal virtual onlyOwner {
        _royalties[tokenId] = RoyaltyReceiver({
            creator: _creator,
            royaltyPercent: _royaltyPercent
        });
        emit RoyaltySet(tokenId, _creator, _royaltyPercent);
    }

    /**
     * @dev Creates a new token for `to`. Its token ID will be automatically
     * assigned (and available on the emitted {IERC721-Transfer} event), and the token
     * URI autogenerated based on the base URI passed at construction.
     *
     * See {ERC721-_mint}.
     *
     * Requirements:
     *
     * - the caller must have the `MINTER_ROLE`.
     *
     */
    function mint(address to, string memory tokenURI) public virtual payable returns (uint256) {
        require(msg.value >= MINT_PRICE, "Not enough ETH sent; check price!");
        require(!paused(), "ERC721Pausable: token transfer while paused");

        _safeMint(to, _tokenCounter);
        emit Mint(to, _tokenCounter, tokenURI, _creator, _royaltyPercent);

        _setTokenURI(_tokenCounter, tokenURI);
        _setRoyalty(_tokenCounter);
        _tokenURIs.push(tokenURI);

        uint256 creator_payout = getMintPayoutForCreator(MINT_PRICE);

        (bool sent, bytes memory data) = _creator.call{value: creator_payout}("");
        require(sent, "Failed to send Ether to Creator");

        emit CreatorMintPayout(_tokenCounter, _creator, creator_payout);

        ++_tokenCounter;

        return _tokenCounter;
    }

    function getMintPayoutForCreator(uint256 salePrice) public view returns (uint256) {
        uint256 num = SafeMath.mul(_mash_fee, salePrice); 
        return SafeMath.div(num, 100);
    }

    function getSalePayoutForCreator(uint8 royaltyPercent, uint256 salePrice) public pure returns (uint256) {
        uint256 num = SafeMath.mul(royaltyPercent, salePrice); 
        return SafeMath.div(num, 100);
    }
    
    /**
     * @dev Pauses all token transfers.
     *
     * See {ERC721Pausable} and {Pausable-_pause}.
     *
     * Requirements:
     *
     * - the caller must have the `PAUSER_ROLE`.
     */
    function pause() public virtual {
        require(hasRole(PAUSER_ROLE, _msgSender()), "ERC721PresetMinterPauserAutoId: must have pauser role to pause");
        _pause();
    }

    /**
     * @dev Unpauses all token transfers.
     *
     * See {ERC721Pausable} and {Pausable-_unpause}.
     *
     * Requirements:
     *
     * - the caller must have the `PAUSER_ROLE`.
     */
    function unpause() public virtual {
        require(hasRole(PAUSER_ROLE, _msgSender()), "ERC721PresetMinterPauserAutoId: must have pauser role to unpause");
        _unpause();
    }

    /**
     * @dev See {IERC165-supportsInterface}.
     */
    function supportsInterface(bytes4 interfaceId)
        public
        view
        virtual
        override(AccessControlEnumerableUpgradeable, ERC721Upgradeable)
        // override(ERC721A, ERC2981Base) 
        returns (bool)
    {
        return super.supportsInterface(interfaceId);
    }

    /**
     * @dev This empty reserved space is put in place to allow future versions to add new
     * variables without shifting down storage in the inheritance chain.
     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps
     */
    uint256[48] private __gap;
}